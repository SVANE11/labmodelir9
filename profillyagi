import numpy as np
from math import *
import matplotlib.pyplot as plt

grad = pi / 180
g = 9.81
ro = 1.240
a = 340

x_0 = 0
y_0 = 0
V_0 = 100
theta_0 = 30
mass = 30
S_m = pi * 0.1**2 / 4

def C_x(M):
    return 0.44

def thrust(t):
    if t < 2:
        return 0
    elif t < 4:
        return 80
    elif t < 6:
        return 110
    else:
        return 0

Y_0 = np.array([
    x_0,
    y_0,
    V_0 * cos(theta_0 * grad),
    V_0 * sin(theta_0 * grad)
])

def f(t, Y):
    x, y, V_x, V_y = Y
    V = sqrt(V_x**2 + V_y**2)
    
    if V > 0:
        M = V / a
        F_drag = 0.5 * ro * V**2 * S_m * C_x(M)
        F_drag_x = -F_drag * V_x / V
        F_drag_y = -F_drag * V_y / V
    else:
        F_drag_x = 0
        F_drag_y = 0
    
    P = thrust(t)
    P_x = P * cos(theta_0 * grad)
    P_y = P * sin(theta_0 * grad)

    a_thrust_x = P_x / mass
    a_thrust_y = P_y / mass
    a_x = a_thrust_x + F_drag_x / mass
    a_y = a_thrust_y + F_drag_y / mass - g
    
    return [V_x, V_y, a_x, a_y]


def euler_constant_step(t_0, t_1, y_0, dYdt, step=0.001):
    t_points = [t_0]
    y_points = [y_0.copy()]
    
    current_t = t_0
    current_y = y_0.copy()
    
    while current_t < t_1 and current_y[1] >= 0:
        derivative = np.array(dYdt(current_t, current_y))
        new_y = current_y + step * derivative
        current_t += step
        
        if new_y[1] < 0:
            dt_interp = step * current_y[1] / (current_y[1] - new_y[1])
            t_fall = current_t - step + dt_interp
            y_fall = current_y + dt_interp * derivative
            t_points.append(t_fall)
            y_points.append(y_fall)
            break
        else:
            t_points.append(current_t)
            y_points.append(new_y)
            current_y = new_y
    
    return np.array(t_points), np.array(y_points)

t, y = euler_constant_step(0, 20, Y_0, f, step=0.001)
valid_indices = y[:, 1] >= 0
t_valid = t[valid_indices]
y_valid = y[valid_indices]


accels_x = []
accels_y = []
thrust_accels_x = []
thrust_accels_y = []

for i in range(len(t_valid)):

    accel = f(t_valid[i], y_valid[i])
    accels_x.append(accel[2])
    accels_y.append(accel[3])
    
    P = thrust(t_valid[i])
    thrust_accels_x.append(P * cos(theta_0 * grad) / mass)
    thrust_accels_y.append(P * sin(theta_0 * grad) / mass)

accels_x = np.array(accels_x)
accels_y = np.array(accels_y)
thrust_accels_x = np.array(thrust_accels_x)
thrust_accels_y = np.array(thrust_accels_y)


accels_total = np.sqrt(accels_x**2 + accels_y**2)
thrust_accels_total = np.sqrt(thrust_accels_x**2 + thrust_accels_y**2)


plt.figure(figsize=(15, 10))

plt.subplot(3, 1, 1)
t_thrust = np.linspace(0, 12, 500)
thrust_vals = [thrust(t_val) for t_val in t_thrust]
plt.plot(t_thrust, thrust_vals, 'r-', linewidth=2)
plt.fill_between(t_thrust, thrust_vals, alpha=0.3, color='red')
plt.ylabel('Тяга, Н', fontsize=12)
plt.xlabel('Время, с', fontsize=12)
plt.title('Влияние профиля тяги на ускорение', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.xlim(0, 12)
plt.tight_layout()
plt.show()
